package sdk

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *JobProcessStatus) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = JobProcessStatus(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z JobProcessStatus) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z JobProcessStatus) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *JobProcessStatus) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = JobProcessStatus(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z JobProcessStatus) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SystemActivityLog) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "scope":
			z.Scope, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Scope")
				return
			}
		case "message":
			z.Message, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Message")
				return
			}
		case "level":
			z.Level, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Level")
				return
			}
		case "timestamp":
			z.Timestamp, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SystemActivityLog) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "scope"
	err = en.Append(0x84, 0xa5, 0x73, 0x63, 0x6f, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Scope)
	if err != nil {
		err = msgp.WrapError(err, "Scope")
		return
	}
	// write "message"
	err = en.Append(0xa7, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Message)
	if err != nil {
		err = msgp.WrapError(err, "Message")
		return
	}
	// write "level"
	err = en.Append(0xa5, 0x6c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.Level)
	if err != nil {
		err = msgp.WrapError(err, "Level")
		return
	}
	// write "timestamp"
	err = en.Append(0xa9, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Timestamp)
	if err != nil {
		err = msgp.WrapError(err, "Timestamp")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SystemActivityLog) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "scope"
	o = append(o, 0x84, 0xa5, 0x73, 0x63, 0x6f, 0x70, 0x65)
	o = msgp.AppendString(o, z.Scope)
	// string "message"
	o = append(o, 0xa7, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65)
	o = msgp.AppendString(o, z.Message)
	// string "level"
	o = append(o, 0xa5, 0x6c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Level)
	// string "timestamp"
	o = append(o, 0xa9, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70)
	o = msgp.AppendInt64(o, z.Timestamp)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SystemActivityLog) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "scope":
			z.Scope, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Scope")
				return
			}
		case "message":
			z.Message, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Message")
				return
			}
		case "level":
			z.Level, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Level")
				return
			}
		case "timestamp":
			z.Timestamp, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Timestamp")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SystemActivityLog) Msgsize() (s int) {
	s = 1 + 6 + msgp.StringPrefixSize + len(z.Scope) + 8 + msgp.StringPrefixSize + len(z.Message) + 6 + msgp.StringPrefixSize + len(z.Level) + 10 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Task) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "description":
			z.Description, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "version":
			z.Version, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "data":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Data")
					return
				}
				switch msgp.UnsafeString(field) {
				case "name":
					z.Data.Name, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Data", "Name")
						return
					}
				case "properties":
					err = z.Data.Properties.DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Properties")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Data")
						return
					}
				}
			}
		case "properties":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Properties")
				return
			}
			if z.Properties == nil {
				z.Properties = make(map[string]interface{}, zb0003)
			} else if len(z.Properties) > 0 {
				for key := range z.Properties {
					delete(z.Properties, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0001 string
				var za0002 interface{}
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Properties")
					return
				}
				za0002, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Properties", za0001)
					return
				}
				z.Properties[za0001] = za0002
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Task) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "id"
	err = en.Append(0x86, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "name"
	err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "description"
	err = en.Append(0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Description)
	if err != nil {
		err = msgp.WrapError(err, "Description")
		return
	}
	// write "version"
	err = en.Append(0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Version)
	if err != nil {
		err = msgp.WrapError(err, "Version")
		return
	}
	// write "data"
	err = en.Append(0xa4, 0x64, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	// map header, size 2
	// write "name"
	err = en.Append(0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Data.Name)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Name")
		return
	}
	// write "properties"
	err = en.Append(0xaa, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = z.Data.Properties.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Properties")
		return
	}
	// write "properties"
	err = en.Append(0xaa, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Properties)))
	if err != nil {
		err = msgp.WrapError(err, "Properties")
		return
	}
	for za0001, za0002 := range z.Properties {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Properties")
			return
		}
		err = en.WriteIntf(za0002)
		if err != nil {
			err = msgp.WrapError(err, "Properties", za0001)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Task) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "id"
	o = append(o, 0x86, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "description"
	o = append(o, 0xab, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "version"
	o = append(o, 0xa7, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Version)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	// map header, size 2
	// string "name"
	o = append(o, 0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Data.Name)
	// string "properties"
	o = append(o, 0xaa, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73)
	o, err = z.Data.Properties.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Properties")
		return
	}
	// string "properties"
	o = append(o, 0xaa, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Properties)))
	for za0001, za0002 := range z.Properties {
		o = msgp.AppendString(o, za0001)
		o, err = msgp.AppendIntf(o, za0002)
		if err != nil {
			err = msgp.WrapError(err, "Properties", za0001)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Task) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "version":
			z.Version, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Version")
				return
			}
		case "data":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Data")
					return
				}
				switch msgp.UnsafeString(field) {
				case "name":
					z.Data.Name, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Name")
						return
					}
				case "properties":
					bts, err = z.Data.Properties.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Properties")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data")
						return
					}
				}
			}
		case "properties":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Properties")
				return
			}
			if z.Properties == nil {
				z.Properties = make(map[string]interface{}, zb0003)
			} else if len(z.Properties) > 0 {
				for key := range z.Properties {
					delete(z.Properties, key)
				}
			}
			for zb0003 > 0 {
				var za0001 string
				var za0002 interface{}
				zb0003--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Properties")
					return
				}
				za0002, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Properties", za0001)
					return
				}
				z.Properties[za0001] = za0002
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Task) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + msgp.StringPrefixSize + len(z.Description) + 8 + msgp.StringPrefixSize + len(z.Version) + 5 + 1 + 5 + msgp.StringPrefixSize + len(z.Data.Name) + 11 + z.Data.Properties.Msgsize() + 11 + msgp.MapHeaderSize
	if z.Properties != nil {
		for za0001, za0002 := range z.Properties {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.GuessSize(za0002)
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TaskContext) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "previous_task_id":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PreviousTaskID")
					return
				}
				z.PreviousTaskID = nil
			} else {
				if z.PreviousTaskID == nil {
					z.PreviousTaskID = new(string)
				}
				*z.PreviousTaskID, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "PreviousTaskID")
					return
				}
			}
		case "current_task_id":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "CurrentTaskID")
					return
				}
				z.CurrentTaskID = nil
			} else {
				if z.CurrentTaskID == nil {
					z.CurrentTaskID = new(string)
				}
				*z.CurrentTaskID, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "CurrentTaskID")
					return
				}
			}
		case "next_task_id":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "NextTaskID")
					return
				}
				z.NextTaskID = nil
			} else {
				if z.NextTaskID == nil {
					z.NextTaskID = new(string)
				}
				*z.NextTaskID, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "NextTaskID")
					return
				}
			}
		case "steps":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Steps")
				return
			}
			if z.Steps == nil {
				z.Steps = make(map[string]TaskStepState, zb0002)
			} else if len(z.Steps) > 0 {
				for key := range z.Steps {
					delete(z.Steps, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 TaskStepState
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Steps")
					return
				}
				err = za0002.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Steps", za0001)
					return
				}
				z.Steps[za0001] = za0002
			}
		case "env":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Env")
				return
			}
			if z.Env == nil {
				z.Env = make(map[string]string, zb0003)
			} else if len(z.Env) > 0 {
				for key := range z.Env {
					delete(z.Env, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				var za0004 string
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Env")
					return
				}
				za0004, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Env", za0003)
					return
				}
				z.Env[za0003] = za0004
			}
		case "input":
			var zb0004 uint32
			zb0004, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Input")
				return
			}
			if z.Input == nil {
				z.Input = make(map[string]interface{}, zb0004)
			} else if len(z.Input) > 0 {
				for key := range z.Input {
					delete(z.Input, key)
				}
			}
			for zb0004 > 0 {
				zb0004--
				var za0005 string
				var za0006 interface{}
				za0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Input")
					return
				}
				za0006, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Input", za0005)
					return
				}
				z.Input[za0005] = za0006
			}
		case "job":
			var zb0005 uint32
			zb0005, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Job")
				return
			}
			for zb0005 > 0 {
				zb0005--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Job")
					return
				}
				switch msgp.UnsafeString(field) {
				case "id":
					z.Job.ID, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Job", "ID")
						return
					}
				case "workflow_id":
					z.Job.WorkflowID, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Job", "WorkflowID")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Job")
						return
					}
				}
			}
		case "step":
			err = z.Step.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Step")
				return
			}
		case "workflow":
			var zb0006 uint32
			zb0006, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Workflow")
				return
			}
			for zb0006 > 0 {
				zb0006--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Workflow")
					return
				}
				switch msgp.UnsafeString(field) {
				case "id":
					z.Workflow.ID, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Workflow", "ID")
						return
					}
				case "name":
					z.Workflow.Name, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Workflow", "Name")
						return
					}
				case "revision":
					z.Workflow.Revision, err = dc.ReadInt64()
					if err != nil {
						err = msgp.WrapError(err, "Workflow", "Revision")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Workflow")
						return
					}
				}
			}
		case "task":
			err = z.Task.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Task")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TaskContext) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 10
	// write "previous_task_id"
	err = en.Append(0x8a, 0xb0, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x5f, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	if z.PreviousTaskID == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteString(*z.PreviousTaskID)
		if err != nil {
			err = msgp.WrapError(err, "PreviousTaskID")
			return
		}
	}
	// write "current_task_id"
	err = en.Append(0xaf, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	if z.CurrentTaskID == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteString(*z.CurrentTaskID)
		if err != nil {
			err = msgp.WrapError(err, "CurrentTaskID")
			return
		}
	}
	// write "next_task_id"
	err = en.Append(0xac, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	if z.NextTaskID == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteString(*z.NextTaskID)
		if err != nil {
			err = msgp.WrapError(err, "NextTaskID")
			return
		}
	}
	// write "steps"
	err = en.Append(0xa5, 0x73, 0x74, 0x65, 0x70, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Steps)))
	if err != nil {
		err = msgp.WrapError(err, "Steps")
		return
	}
	for za0001, za0002 := range z.Steps {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Steps")
			return
		}
		err = za0002.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Steps", za0001)
			return
		}
	}
	// write "env"
	err = en.Append(0xa3, 0x65, 0x6e, 0x76)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Env)))
	if err != nil {
		err = msgp.WrapError(err, "Env")
		return
	}
	for za0003, za0004 := range z.Env {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "Env")
			return
		}
		err = en.WriteString(za0004)
		if err != nil {
			err = msgp.WrapError(err, "Env", za0003)
			return
		}
	}
	// write "input"
	err = en.Append(0xa5, 0x69, 0x6e, 0x70, 0x75, 0x74)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Input)))
	if err != nil {
		err = msgp.WrapError(err, "Input")
		return
	}
	for za0005, za0006 := range z.Input {
		err = en.WriteString(za0005)
		if err != nil {
			err = msgp.WrapError(err, "Input")
			return
		}
		err = en.WriteIntf(za0006)
		if err != nil {
			err = msgp.WrapError(err, "Input", za0005)
			return
		}
	}
	// write "job"
	err = en.Append(0xa3, 0x6a, 0x6f, 0x62)
	if err != nil {
		return
	}
	// map header, size 2
	// write "id"
	err = en.Append(0x82, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.Job.ID)
	if err != nil {
		err = msgp.WrapError(err, "Job", "ID")
		return
	}
	// write "workflow_id"
	err = en.Append(0xab, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.Job.WorkflowID)
	if err != nil {
		err = msgp.WrapError(err, "Job", "WorkflowID")
		return
	}
	// write "step"
	err = en.Append(0xa4, 0x73, 0x74, 0x65, 0x70)
	if err != nil {
		return
	}
	err = z.Step.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Step")
		return
	}
	// write "workflow"
	err = en.Append(0xa8, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77)
	if err != nil {
		return
	}
	// map header, size 3
	// write "id"
	err = en.Append(0x83, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.Workflow.ID)
	if err != nil {
		err = msgp.WrapError(err, "Workflow", "ID")
		return
	}
	// write "name"
	err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Workflow.Name)
	if err != nil {
		err = msgp.WrapError(err, "Workflow", "Name")
		return
	}
	// write "revision"
	err = en.Append(0xa8, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Workflow.Revision)
	if err != nil {
		err = msgp.WrapError(err, "Workflow", "Revision")
		return
	}
	// write "task"
	err = en.Append(0xa4, 0x74, 0x61, 0x73, 0x6b)
	if err != nil {
		return
	}
	err = z.Task.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Task")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TaskContext) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "previous_task_id"
	o = append(o, 0x8a, 0xb0, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x5f, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64)
	if z.PreviousTaskID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.PreviousTaskID)
	}
	// string "current_task_id"
	o = append(o, 0xaf, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64)
	if z.CurrentTaskID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.CurrentTaskID)
	}
	// string "next_task_id"
	o = append(o, 0xac, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64)
	if z.NextTaskID == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendString(o, *z.NextTaskID)
	}
	// string "steps"
	o = append(o, 0xa5, 0x73, 0x74, 0x65, 0x70, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.Steps)))
	for za0001, za0002 := range z.Steps {
		o = msgp.AppendString(o, za0001)
		o, err = za0002.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Steps", za0001)
			return
		}
	}
	// string "env"
	o = append(o, 0xa3, 0x65, 0x6e, 0x76)
	o = msgp.AppendMapHeader(o, uint32(len(z.Env)))
	for za0003, za0004 := range z.Env {
		o = msgp.AppendString(o, za0003)
		o = msgp.AppendString(o, za0004)
	}
	// string "input"
	o = append(o, 0xa5, 0x69, 0x6e, 0x70, 0x75, 0x74)
	o = msgp.AppendMapHeader(o, uint32(len(z.Input)))
	for za0005, za0006 := range z.Input {
		o = msgp.AppendString(o, za0005)
		o, err = msgp.AppendIntf(o, za0006)
		if err != nil {
			err = msgp.WrapError(err, "Input", za0005)
			return
		}
	}
	// string "job"
	o = append(o, 0xa3, 0x6a, 0x6f, 0x62)
	// map header, size 2
	// string "id"
	o = append(o, 0x82, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.Job.ID)
	// string "workflow_id"
	o = append(o, 0xab, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.Job.WorkflowID)
	// string "step"
	o = append(o, 0xa4, 0x73, 0x74, 0x65, 0x70)
	o, err = z.Step.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Step")
		return
	}
	// string "workflow"
	o = append(o, 0xa8, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77)
	// map header, size 3
	// string "id"
	o = append(o, 0x83, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.Workflow.ID)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Workflow.Name)
	// string "revision"
	o = append(o, 0xa8, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt64(o, z.Workflow.Revision)
	// string "task"
	o = append(o, 0xa4, 0x74, 0x61, 0x73, 0x6b)
	o, err = z.Task.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Task")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TaskContext) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "previous_task_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PreviousTaskID = nil
			} else {
				if z.PreviousTaskID == nil {
					z.PreviousTaskID = new(string)
				}
				*z.PreviousTaskID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PreviousTaskID")
					return
				}
			}
		case "current_task_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.CurrentTaskID = nil
			} else {
				if z.CurrentTaskID == nil {
					z.CurrentTaskID = new(string)
				}
				*z.CurrentTaskID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CurrentTaskID")
					return
				}
			}
		case "next_task_id":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.NextTaskID = nil
			} else {
				if z.NextTaskID == nil {
					z.NextTaskID = new(string)
				}
				*z.NextTaskID, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NextTaskID")
					return
				}
			}
		case "steps":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Steps")
				return
			}
			if z.Steps == nil {
				z.Steps = make(map[string]TaskStepState, zb0002)
			} else if len(z.Steps) > 0 {
				for key := range z.Steps {
					delete(z.Steps, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 TaskStepState
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Steps")
					return
				}
				bts, err = za0002.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Steps", za0001)
					return
				}
				z.Steps[za0001] = za0002
			}
		case "env":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Env")
				return
			}
			if z.Env == nil {
				z.Env = make(map[string]string, zb0003)
			} else if len(z.Env) > 0 {
				for key := range z.Env {
					delete(z.Env, key)
				}
			}
			for zb0003 > 0 {
				var za0003 string
				var za0004 string
				zb0003--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Env")
					return
				}
				za0004, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Env", za0003)
					return
				}
				z.Env[za0003] = za0004
			}
		case "input":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Input")
				return
			}
			if z.Input == nil {
				z.Input = make(map[string]interface{}, zb0004)
			} else if len(z.Input) > 0 {
				for key := range z.Input {
					delete(z.Input, key)
				}
			}
			for zb0004 > 0 {
				var za0005 string
				var za0006 interface{}
				zb0004--
				za0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Input")
					return
				}
				za0006, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Input", za0005)
					return
				}
				z.Input[za0005] = za0006
			}
		case "job":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Job")
				return
			}
			for zb0005 > 0 {
				zb0005--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Job")
					return
				}
				switch msgp.UnsafeString(field) {
				case "id":
					z.Job.ID, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Job", "ID")
						return
					}
				case "workflow_id":
					z.Job.WorkflowID, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Job", "WorkflowID")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Job")
						return
					}
				}
			}
		case "step":
			bts, err = z.Step.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Step")
				return
			}
		case "workflow":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Workflow")
				return
			}
			for zb0006 > 0 {
				zb0006--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Workflow")
					return
				}
				switch msgp.UnsafeString(field) {
				case "id":
					z.Workflow.ID, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Workflow", "ID")
						return
					}
				case "name":
					z.Workflow.Name, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Workflow", "Name")
						return
					}
				case "revision":
					z.Workflow.Revision, bts, err = msgp.ReadInt64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Workflow", "Revision")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Workflow")
						return
					}
				}
			}
		case "task":
			bts, err = z.Task.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Task")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TaskContext) Msgsize() (s int) {
	s = 1 + 17
	if z.PreviousTaskID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.PreviousTaskID)
	}
	s += 16
	if z.CurrentTaskID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.CurrentTaskID)
	}
	s += 13
	if z.NextTaskID == nil {
		s += msgp.NilSize
	} else {
		s += msgp.StringPrefixSize + len(*z.NextTaskID)
	}
	s += 6 + msgp.MapHeaderSize
	if z.Steps != nil {
		for za0001, za0002 := range z.Steps {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + za0002.Msgsize()
		}
	}
	s += 4 + msgp.MapHeaderSize
	if z.Env != nil {
		for za0003, za0004 := range z.Env {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.StringPrefixSize + len(za0004)
		}
	}
	s += 6 + msgp.MapHeaderSize
	if z.Input != nil {
		for za0005, za0006 := range z.Input {
			_ = za0006
			s += msgp.StringPrefixSize + len(za0005) + msgp.GuessSize(za0006)
		}
	}
	s += 4 + 1 + 3 + msgp.StringPrefixSize + len(z.Job.ID) + 12 + msgp.StringPrefixSize + len(z.Job.WorkflowID) + 5 + z.Step.Msgsize() + 9 + 1 + 3 + msgp.StringPrefixSize + len(z.Workflow.ID) + 5 + msgp.StringPrefixSize + len(z.Workflow.Name) + 9 + msgp.Int64Size + 5 + z.Task.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TaskProperties) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "input":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Input")
				return
			}
			if z.Input == nil {
				z.Input = make(map[string]interface{}, zb0002)
			} else if len(z.Input) > 0 {
				for key := range z.Input {
					delete(z.Input, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 interface{}
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Input")
					return
				}
				za0002, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Input", za0001)
					return
				}
				z.Input[za0001] = za0002
			}
		case "output":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Output")
				return
			}
			if z.Output == nil {
				z.Output = make(map[string]interface{}, zb0003)
			} else if len(z.Output) > 0 {
				for key := range z.Output {
					delete(z.Output, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				var za0004 interface{}
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Output")
					return
				}
				za0004, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Output", za0003)
					return
				}
				z.Output[za0003] = za0004
			}
		case "authentication":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Authentication")
					return
				}
				z.Authentication = nil
			} else {
				if z.Authentication == nil {
					z.Authentication = new(map[string]interface{})
				}
				var zb0004 uint32
				zb0004, err = dc.ReadMapHeader()
				if err != nil {
					err = msgp.WrapError(err, "Authentication")
					return
				}
				if *z.Authentication == nil {
					*z.Authentication = make(map[string]interface{}, zb0004)
				} else if len(*z.Authentication) > 0 {
					for key := range *z.Authentication {
						delete(*z.Authentication, key)
					}
				}
				for zb0004 > 0 {
					zb0004--
					var za0005 string
					var za0006 interface{}
					za0005, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Authentication")
						return
					}
					za0006, err = dc.ReadIntf()
					if err != nil {
						err = msgp.WrapError(err, "Authentication", za0005)
						return
					}
					*z.Authentication[za0005] = za0006
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TaskProperties) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "input"
	err = en.Append(0x83, 0xa5, 0x69, 0x6e, 0x70, 0x75, 0x74)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Input)))
	if err != nil {
		err = msgp.WrapError(err, "Input")
		return
	}
	for za0001, za0002 := range z.Input {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Input")
			return
		}
		err = en.WriteIntf(za0002)
		if err != nil {
			err = msgp.WrapError(err, "Input", za0001)
			return
		}
	}
	// write "output"
	err = en.Append(0xa6, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Output)))
	if err != nil {
		err = msgp.WrapError(err, "Output")
		return
	}
	for za0003, za0004 := range z.Output {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "Output")
			return
		}
		err = en.WriteIntf(za0004)
		if err != nil {
			err = msgp.WrapError(err, "Output", za0003)
			return
		}
	}
	// write "authentication"
	err = en.Append(0xae, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	if z.Authentication == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteMapHeader(uint32(len(*z.Authentication)))
		if err != nil {
			err = msgp.WrapError(err, "Authentication")
			return
		}
		for za0005, za0006 := range *z.Authentication {
			err = en.WriteString(za0005)
			if err != nil {
				err = msgp.WrapError(err, "Authentication")
				return
			}
			err = en.WriteIntf(za0006)
			if err != nil {
				err = msgp.WrapError(err, "Authentication", za0005)
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TaskProperties) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "input"
	o = append(o, 0x83, 0xa5, 0x69, 0x6e, 0x70, 0x75, 0x74)
	o = msgp.AppendMapHeader(o, uint32(len(z.Input)))
	for za0001, za0002 := range z.Input {
		o = msgp.AppendString(o, za0001)
		o, err = msgp.AppendIntf(o, za0002)
		if err != nil {
			err = msgp.WrapError(err, "Input", za0001)
			return
		}
	}
	// string "output"
	o = append(o, 0xa6, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74)
	o = msgp.AppendMapHeader(o, uint32(len(z.Output)))
	for za0003, za0004 := range z.Output {
		o = msgp.AppendString(o, za0003)
		o, err = msgp.AppendIntf(o, za0004)
		if err != nil {
			err = msgp.WrapError(err, "Output", za0003)
			return
		}
	}
	// string "authentication"
	o = append(o, 0xae, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	if z.Authentication == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendMapHeader(o, uint32(len(*z.Authentication)))
		for za0005, za0006 := range *z.Authentication {
			o = msgp.AppendString(o, za0005)
			o, err = msgp.AppendIntf(o, za0006)
			if err != nil {
				err = msgp.WrapError(err, "Authentication", za0005)
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TaskProperties) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "input":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Input")
				return
			}
			if z.Input == nil {
				z.Input = make(map[string]interface{}, zb0002)
			} else if len(z.Input) > 0 {
				for key := range z.Input {
					delete(z.Input, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 interface{}
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Input")
					return
				}
				za0002, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Input", za0001)
					return
				}
				z.Input[za0001] = za0002
			}
		case "output":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Output")
				return
			}
			if z.Output == nil {
				z.Output = make(map[string]interface{}, zb0003)
			} else if len(z.Output) > 0 {
				for key := range z.Output {
					delete(z.Output, key)
				}
			}
			for zb0003 > 0 {
				var za0003 string
				var za0004 interface{}
				zb0003--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Output")
					return
				}
				za0004, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Output", za0003)
					return
				}
				z.Output[za0003] = za0004
			}
		case "authentication":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Authentication = nil
			} else {
				if z.Authentication == nil {
					z.Authentication = new(map[string]interface{})
				}
				var zb0004 uint32
				zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Authentication")
					return
				}
				if *z.Authentication == nil {
					*z.Authentication = make(map[string]interface{}, zb0004)
				} else if len(*z.Authentication) > 0 {
					for key := range *z.Authentication {
						delete(*z.Authentication, key)
					}
				}
				for zb0004 > 0 {
					var za0005 string
					var za0006 interface{}
					zb0004--
					za0005, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Authentication")
						return
					}
					za0006, bts, err = msgp.ReadIntfBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Authentication", za0005)
						return
					}
					*z.Authentication[za0005] = za0006
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TaskProperties) Msgsize() (s int) {
	s = 1 + 6 + msgp.MapHeaderSize
	if z.Input != nil {
		for za0001, za0002 := range z.Input {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.GuessSize(za0002)
		}
	}
	s += 7 + msgp.MapHeaderSize
	if z.Output != nil {
		for za0003, za0004 := range z.Output {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.GuessSize(za0004)
		}
	}
	s += 15
	if z.Authentication == nil {
		s += msgp.NilSize
	} else {
		s += msgp.MapHeaderSize
		if *z.Authentication != nil {
			for za0005, za0006 := range *z.Authentication {
				_ = za0006
				s += msgp.StringPrefixSize + len(za0005) + msgp.GuessSize(za0006)
			}
		}
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TaskResult) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "output":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Output")
				return
			}
			if z.Output == nil {
				z.Output = make(map[string]interface{}, zb0002)
			} else if len(z.Output) > 0 {
				for key := range z.Output {
					delete(z.Output, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 interface{}
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Output")
					return
				}
				za0002, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Output", za0001)
					return
				}
				z.Output[za0001] = za0002
			}
		case "errors":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			if cap(z.Errors) >= int(zb0003) {
				z.Errors = (z.Errors)[:zb0003]
			} else {
				z.Errors = make([]SystemActivityLog, zb0003)
			}
			for za0003 := range z.Errors {
				err = z.Errors[za0003].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0003)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TaskResult) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "output"
	err = en.Append(0x82, 0xa6, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Output)))
	if err != nil {
		err = msgp.WrapError(err, "Output")
		return
	}
	for za0001, za0002 := range z.Output {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Output")
			return
		}
		err = en.WriteIntf(za0002)
		if err != nil {
			err = msgp.WrapError(err, "Output", za0001)
			return
		}
	}
	// write "errors"
	err = en.Append(0xa6, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Errors)))
	if err != nil {
		err = msgp.WrapError(err, "Errors")
		return
	}
	for za0003 := range z.Errors {
		err = z.Errors[za0003].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Errors", za0003)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TaskResult) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "output"
	o = append(o, 0x82, 0xa6, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74)
	o = msgp.AppendMapHeader(o, uint32(len(z.Output)))
	for za0001, za0002 := range z.Output {
		o = msgp.AppendString(o, za0001)
		o, err = msgp.AppendIntf(o, za0002)
		if err != nil {
			err = msgp.WrapError(err, "Output", za0001)
			return
		}
	}
	// string "errors"
	o = append(o, 0xa6, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Errors)))
	for za0003 := range z.Errors {
		o, err = z.Errors[za0003].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Errors", za0003)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TaskResult) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "output":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Output")
				return
			}
			if z.Output == nil {
				z.Output = make(map[string]interface{}, zb0002)
			} else if len(z.Output) > 0 {
				for key := range z.Output {
					delete(z.Output, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 interface{}
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Output")
					return
				}
				za0002, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Output", za0001)
					return
				}
				z.Output[za0001] = za0002
			}
		case "errors":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			if cap(z.Errors) >= int(zb0003) {
				z.Errors = (z.Errors)[:zb0003]
			} else {
				z.Errors = make([]SystemActivityLog, zb0003)
			}
			for za0003 := range z.Errors {
				bts, err = z.Errors[za0003].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0003)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TaskResult) Msgsize() (s int) {
	s = 1 + 7 + msgp.MapHeaderSize
	if z.Output != nil {
		for za0001, za0002 := range z.Output {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.GuessSize(za0002)
		}
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0003 := range z.Errors {
		s += z.Errors[za0003].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TaskStep) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "label":
			z.Label, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Label")
				return
			}
		case "data":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "Data")
					return
				}
				switch msgp.UnsafeString(field) {
				case "name":
					z.Data.Name, err = dc.ReadString()
					if err != nil {
						err = msgp.WrapError(err, "Data", "Name")
						return
					}
				case "properties":
					err = z.Data.Properties.DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Properties")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "Data")
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TaskStep) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "id"
	err = en.Append(0x83, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "label"
	err = en.Append(0xa5, 0x6c, 0x61, 0x62, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.Label)
	if err != nil {
		err = msgp.WrapError(err, "Label")
		return
	}
	// write "data"
	err = en.Append(0xa4, 0x64, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	// map header, size 2
	// write "name"
	err = en.Append(0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Data.Name)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Name")
		return
	}
	// write "properties"
	err = en.Append(0xaa, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = z.Data.Properties.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Properties")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TaskStep) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "id"
	o = append(o, 0x83, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "label"
	o = append(o, 0xa5, 0x6c, 0x61, 0x62, 0x65, 0x6c)
	o = msgp.AppendString(o, z.Label)
	// string "data"
	o = append(o, 0xa4, 0x64, 0x61, 0x74, 0x61)
	// map header, size 2
	// string "name"
	o = append(o, 0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Data.Name)
	// string "properties"
	o = append(o, 0xaa, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73)
	o, err = z.Data.Properties.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Data", "Properties")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TaskStep) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "label":
			z.Label, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Label")
				return
			}
		case "data":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Data")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "Data")
					return
				}
				switch msgp.UnsafeString(field) {
				case "name":
					z.Data.Name, bts, err = msgp.ReadStringBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Name")
						return
					}
				case "properties":
					bts, err = z.Data.Properties.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data", "Properties")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "Data")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TaskStep) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 6 + msgp.StringPrefixSize + len(z.Label) + 5 + 1 + 5 + msgp.StringPrefixSize + len(z.Data.Name) + 11 + z.Data.Properties.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TaskStepData) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "properties":
			err = z.Properties.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Properties")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TaskStepData) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "name"
	err = en.Append(0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "properties"
	err = en.Append(0xaa, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = z.Properties.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Properties")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TaskStepData) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "name"
	o = append(o, 0x82, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "properties"
	o = append(o, 0xaa, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73)
	o, err = z.Properties.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Properties")
		return
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TaskStepData) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "properties":
			bts, err = z.Properties.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Properties")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TaskStepData) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 11 + z.Properties.Msgsize()
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TaskStepState) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "task_id":
			z.TaskID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "TaskID")
				return
			}
		case "input":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Input")
				return
			}
			if z.Input == nil {
				z.Input = make(map[string]interface{}, zb0002)
			} else if len(z.Input) > 0 {
				for key := range z.Input {
					delete(z.Input, key)
				}
			}
			for zb0002 > 0 {
				zb0002--
				var za0001 string
				var za0002 interface{}
				za0001, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Input")
					return
				}
				za0002, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Input", za0001)
					return
				}
				z.Input[za0001] = za0002
			}
		case "output":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "Output")
				return
			}
			if z.Output == nil {
				z.Output = make(map[string]interface{}, zb0003)
			} else if len(z.Output) > 0 {
				for key := range z.Output {
					delete(z.Output, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0003 string
				var za0004 interface{}
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Output")
					return
				}
				za0004, err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "Output", za0003)
					return
				}
				z.Output[za0003] = za0004
			}
		case "errors":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			if cap(z.Errors) >= int(zb0004) {
				z.Errors = (z.Errors)[:zb0004]
			} else {
				z.Errors = make([]SystemActivityLog, zb0004)
			}
			for za0005 := range z.Errors {
				err = z.Errors[za0005].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0005)
					return
				}
			}
		case "status":
			{
				var zb0005 string
				zb0005, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				z.Status = JobProcessStatus(zb0005)
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *TaskStepState) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "task_id"
	err = en.Append(0x85, 0xa7, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.TaskID)
	if err != nil {
		err = msgp.WrapError(err, "TaskID")
		return
	}
	// write "input"
	err = en.Append(0xa5, 0x69, 0x6e, 0x70, 0x75, 0x74)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Input)))
	if err != nil {
		err = msgp.WrapError(err, "Input")
		return
	}
	for za0001, za0002 := range z.Input {
		err = en.WriteString(za0001)
		if err != nil {
			err = msgp.WrapError(err, "Input")
			return
		}
		err = en.WriteIntf(za0002)
		if err != nil {
			err = msgp.WrapError(err, "Input", za0001)
			return
		}
	}
	// write "output"
	err = en.Append(0xa6, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.Output)))
	if err != nil {
		err = msgp.WrapError(err, "Output")
		return
	}
	for za0003, za0004 := range z.Output {
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "Output")
			return
		}
		err = en.WriteIntf(za0004)
		if err != nil {
			err = msgp.WrapError(err, "Output", za0003)
			return
		}
	}
	// write "errors"
	err = en.Append(0xa6, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Errors)))
	if err != nil {
		err = msgp.WrapError(err, "Errors")
		return
	}
	for za0005 := range z.Errors {
		err = z.Errors[za0005].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Errors", za0005)
			return
		}
	}
	// write "status"
	err = en.Append(0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Status))
	if err != nil {
		err = msgp.WrapError(err, "Status")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *TaskStepState) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "task_id"
	o = append(o, 0x85, 0xa7, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.TaskID)
	// string "input"
	o = append(o, 0xa5, 0x69, 0x6e, 0x70, 0x75, 0x74)
	o = msgp.AppendMapHeader(o, uint32(len(z.Input)))
	for za0001, za0002 := range z.Input {
		o = msgp.AppendString(o, za0001)
		o, err = msgp.AppendIntf(o, za0002)
		if err != nil {
			err = msgp.WrapError(err, "Input", za0001)
			return
		}
	}
	// string "output"
	o = append(o, 0xa6, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74)
	o = msgp.AppendMapHeader(o, uint32(len(z.Output)))
	for za0003, za0004 := range z.Output {
		o = msgp.AppendString(o, za0003)
		o, err = msgp.AppendIntf(o, za0004)
		if err != nil {
			err = msgp.WrapError(err, "Output", za0003)
			return
		}
	}
	// string "errors"
	o = append(o, 0xa6, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Errors)))
	for za0005 := range z.Errors {
		o, err = z.Errors[za0005].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Errors", za0005)
			return
		}
	}
	// string "status"
	o = append(o, 0xa6, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73)
	o = msgp.AppendString(o, string(z.Status))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TaskStepState) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "task_id":
			z.TaskID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TaskID")
				return
			}
		case "input":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Input")
				return
			}
			if z.Input == nil {
				z.Input = make(map[string]interface{}, zb0002)
			} else if len(z.Input) > 0 {
				for key := range z.Input {
					delete(z.Input, key)
				}
			}
			for zb0002 > 0 {
				var za0001 string
				var za0002 interface{}
				zb0002--
				za0001, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Input")
					return
				}
				za0002, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Input", za0001)
					return
				}
				z.Input[za0001] = za0002
			}
		case "output":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Output")
				return
			}
			if z.Output == nil {
				z.Output = make(map[string]interface{}, zb0003)
			} else if len(z.Output) > 0 {
				for key := range z.Output {
					delete(z.Output, key)
				}
			}
			for zb0003 > 0 {
				var za0003 string
				var za0004 interface{}
				zb0003--
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Output")
					return
				}
				za0004, bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Output", za0003)
					return
				}
				z.Output[za0003] = za0004
			}
		case "errors":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Errors")
				return
			}
			if cap(z.Errors) >= int(zb0004) {
				z.Errors = (z.Errors)[:zb0004]
			} else {
				z.Errors = make([]SystemActivityLog, zb0004)
			}
			for za0005 := range z.Errors {
				bts, err = z.Errors[za0005].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Errors", za0005)
					return
				}
			}
		case "status":
			{
				var zb0005 string
				zb0005, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Status")
					return
				}
				z.Status = JobProcessStatus(zb0005)
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *TaskStepState) Msgsize() (s int) {
	s = 1 + 8 + msgp.StringPrefixSize + len(z.TaskID) + 6 + msgp.MapHeaderSize
	if z.Input != nil {
		for za0001, za0002 := range z.Input {
			_ = za0002
			s += msgp.StringPrefixSize + len(za0001) + msgp.GuessSize(za0002)
		}
	}
	s += 7 + msgp.MapHeaderSize
	if z.Output != nil {
		for za0003, za0004 := range z.Output {
			_ = za0004
			s += msgp.StringPrefixSize + len(za0003) + msgp.GuessSize(za0004)
		}
	}
	s += 7 + msgp.ArrayHeaderSize
	for za0005 := range z.Errors {
		s += z.Errors[za0005].Msgsize()
	}
	s += 7 + msgp.StringPrefixSize + len(string(z.Status))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Workflow) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "revision":
			z.Revision, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Revision")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z Workflow) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "id"
	err = en.Append(0x83, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "name"
	err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "revision"
	err = en.Append(0xa8, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Revision)
	if err != nil {
		err = msgp.WrapError(err, "Revision")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z Workflow) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "id"
	o = append(o, 0x83, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "revision"
	o = append(o, 0xa8, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt64(o, z.Revision)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Workflow) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "revision":
			z.Revision, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Revision")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z Workflow) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.Name) + 9 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *WorkflowInstance) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "workflow_id":
			z.WorkflowID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "WorkflowID")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z WorkflowInstance) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "id"
	err = en.Append(0x82, 0xa2, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "workflow_id"
	err = en.Append(0xab, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.WorkflowID)
	if err != nil {
		err = msgp.WrapError(err, "WorkflowID")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z WorkflowInstance) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "id"
	o = append(o, 0x82, 0xa2, 0x69, 0x64)
	o = msgp.AppendString(o, z.ID)
	// string "workflow_id"
	o = append(o, 0xab, 0x77, 0x6f, 0x72, 0x6b, 0x66, 0x6c, 0x6f, 0x77, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.WorkflowID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WorkflowInstance) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "id":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "workflow_id":
			z.WorkflowID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WorkflowID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z WorkflowInstance) Msgsize() (s int) {
	s = 1 + 3 + msgp.StringPrefixSize + len(z.ID) + 12 + msgp.StringPrefixSize + len(z.WorkflowID)
	return
}
